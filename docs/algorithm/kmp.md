# KMP

## KMP是什么

Knuth-Morris-Pratt 字符串查找算法，简称为 KMP算法，这个算法由 Donald Knuth、Vaughan Pratt、James H. Morris 三人于 1977 年联合发表，故取这 3 人的姓氏命名此算法。

## KMP解决什么样的问题

常用于在一个文本串 S 内查找一个模式串 P 的出现位置

## 时间复杂度

在一个文本串 S 内查找一个模式串 P 的出现位置的暴力解法时间复杂度为O(m * n)，KMP算法时间复杂度为O(m + n)

## 前缀表

前缀：包含首字母，不包含尾字母的连续子串

后缀：包含尾字母，不包含首字母的连续子串

最长公共前后缀：指的是模式串的子串中前后缀相同的最大数值

```js
// 文本串
const s = 'aabaabaaf'
// 模式串
const p = 'aabaaf'
```

模式串的前缀表

| 子串   | 前缀表               | 后缀表                | 最长公共前后缀 |
|--------|---------------------|---------------------|:--------------:|
| a      | -                   | -                   | 0              |
| aa     | `a`                 | `a`                 | 1              |
| aab    | a aa                | b ab                | 0              |
| aaba   | `a` aa aab          | `a` ba aba          | 1              |
| aabaa  | a `aa` aab aaba     | a `aa` baa abaa     | 2              |
| aabaaf | a aa aab aaba aabaa | f af aaf baaf abaaf | 0              |

这个之上而下的0 -> 1 -> 0 -> 1 -> 2 -> 0就是 `aabaaf` 的 `前缀表`

## next数组

- next数组有很多种表示方法:

  1. 直接使用前缀表作为next数组：字符串不匹配的时候，跳到next数组前一位所对应数值的下标
  2. 前缀表整体右移一位，第一位使用-1补齐：字符串不匹配的时候，直接使用该字符串对应数值的下标
  3. 前缀表整体减一：字符串不匹配的时候，跳到next数组前一位对应的数值+1的下标

- 如何获得next数组（这里我们使用上述的`方法1`来实现next数组）

  设`j`为前缀末尾位置，设`i`为后缀末尾位置

  这里的`j`其实也代表包含`i`之前包括`i`子串的最长公共前后缀的长度

  :::details
  关于指针回溯求next的理解：

  每次求next【i】，可看作前缀与后缀的一次匹配，在该过程中就可以用上之前所求的next，若匹配失败，则像模式串与父串匹配一样，将指针移到next【j-1】上。

  求next过程实际上是dp（动态规划），只与前一个状态有关：

  若不匹配，一直往前退到0或匹配为止

  若匹配，则将之前的结果传递：

  因为之前的结果不为0时，前后缀有相等的部分，所以j所指的实际是与当前值相等的前缀，可视为将前缀从前面拖了过来，就不必将指针从前缀开始匹配了，所以之前的结果是可以传递的。
  :::

  ```js
  function getNext(str) {
    // 初始化
    const next = [0]
    let j = 0
    for(let i = 1; i < str.length; i++) {
      // 处理字符串不相同的情况
      while(j > 0 && str[i] !== str[j]) {
        j = next[j - 1]
      }
      // 处理字符串相同的情况
      if(str[i] === str[j]) {
        // 因为j代表了i之前包含i子串的最长公共前缀的长度
        // 所以当字符串相同的时候，需要对j + 1
        j++
      }
      // 更新next数组
      next[i] = j
    }
    return next
  }
  ```
