import{_ as t,c as d,o as a,V as e}from"./chunks/framework.OaYh-_yc.js";const x=JSON.parse('{"title":"RegExp","description":"","frontmatter":{},"headers":[],"relativePath":"advanced/reg-exp.md","filePath":"advanced/reg-exp.md","lastUpdated":1706930496000}'),r={name:"advanced/reg-exp.md"},s=e('<h1 id="regexp" tabindex="-1">RegExp <a class="header-anchor" href="#regexp" aria-label="Permalink to &quot;RegExp&quot;">​</a></h1><nav class="table-of-contents"><ul><li><a href="#可视化-regexper">可视化：regexper</a></li><li><a href="#快速测试">快速测试</a></li><li><a href="#速查表">速查表</a></li><li><a href="#非贪婪模式">非贪婪模式</a></li><li><a href="#忽略分组">忽略分组</a></li><li><a href="#前瞻和后顾">前瞻和后顾</a></li></ul></nav><h2 id="可视化-regexper" tabindex="-1">可视化：<a href="https://regexper.com" target="_blank" rel="noreferrer">regexper</a> <a class="header-anchor" href="#可视化-regexper" aria-label="Permalink to &quot;可视化：[regexper](https://regexper.com)&quot;">​</a></h2><h2 id="快速测试" tabindex="-1">快速测试 <a class="header-anchor" href="#快速测试" aria-label="Permalink to &quot;快速测试&quot;">​</a></h2><p>待开放...</p><h2 id="速查表" tabindex="-1">速查表 <a class="header-anchor" href="#速查表" aria-label="Permalink to &quot;速查表&quot;">​</a></h2><table><thead><tr><th>规则</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>\\</td><td>转义</td><td></td></tr><tr><td>^</td><td>匹配输入的开始</td><td></td></tr><tr><td>$</td><td>匹配输入的结束</td><td></td></tr><tr><td>*</td><td>匹配前一个表达式0次或多次</td><td></td></tr><tr><td>+</td><td>匹配前一个表达式1次或多次</td><td>等价于 <code>{1,}</code></td></tr><tr><td>?</td><td>匹配前一个表达式0次货1次</td><td>等价于 <code>{0,1}</code></td></tr><tr><td>.</td><td>默认匹配除了换行符之外的任何单个字符</td><td></td></tr><tr><td>x(?=y)</td><td>匹配&#39;x&#39;仅仅当&#39;x&#39;后面跟着&#39;y&#39;</td><td>先行断言</td></tr><tr><td>(?&lt;=y)x</td><td>匹配&#39;x&#39;仅当&#39;x&#39;前面是&#39;y&#39;</td><td>后行断言</td></tr><tr><td>x(?!y)</td><td>仅仅当&#39;x&#39;后面不跟着&#39;y&#39;时匹配&#39;x&#39;</td><td>正向否定查找</td></tr><tr><td>(?&lt;!y)x</td><td>仅仅当&#39;x&#39;前面不是&#39;y&#39;时匹配&#39;x&#39;</td><td>反向否定查找</td></tr><tr><td>x|y</td><td>匹配&#39;x&#39;或者&#39;y&#39;</td><td></td></tr><tr><td>{n}</td><td>匹配了前面一个字符刚好出现了 n 次</td><td>n 是正整数</td></tr><tr><td>{n,}</td><td>匹配前一个字符至少出现了n次</td><td>n 是正整数</td></tr><tr><td>{n,m}</td><td>匹配前面的字符至少n次，最多m次</td><td>m,n 是正整数</td></tr><tr><td>[xyz]</td><td>一个字符集合。匹配方括号中的任意字符</td><td></td></tr><tr><td>[^xyz]</td><td>匹配任何没有包含在方括号中的字符</td><td></td></tr><tr><td>\\b</td><td>匹配一个词的边界，例如在字母和空格之间</td><td></td></tr><tr><td>\\B</td><td>匹配一个非单词边界</td><td></td></tr><tr><td>\\d</td><td>匹配一个数字</td><td></td></tr><tr><td>\\D</td><td>匹配一个非数字字符</td><td></td></tr><tr><td>\\f</td><td>匹配一个换页符</td><td></td></tr><tr><td>\\n</td><td>匹配一个换行符</td><td></td></tr><tr><td>\\r</td><td>匹配一个回车符</td><td></td></tr><tr><td>\\s</td><td>匹配一个空白字符，包括空格、制表符、换页符和换行符</td><td></td></tr><tr><td>\\S</td><td>匹配一个非空白字符</td><td></td></tr><tr><td>\\w</td><td>匹配一个单字字符（字母、数字或者下划线）</td><td></td></tr><tr><td>\\W</td><td>匹配一个非单字字符</td><td></td></tr></tbody></table><h2 id="非贪婪模式" tabindex="-1">非贪婪模式 <a class="header-anchor" href="#非贪婪模式" aria-label="Permalink to &quot;非贪婪模式&quot;">​</a></h2><blockquote><p>让正则表达式尽可能少的匹配，也就是说一旦成功匹配不再继续尝试就是非贪婪模式，做法很简单，在两次后加上<code>?</code>即可</p></blockquote><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;123456789&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">match</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">{3,5}?</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">g</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// [&quot;123&quot;, &quot;456&quot;, &quot;789&quot;]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="忽略分组" tabindex="-1">忽略分组 <a class="header-anchor" href="#忽略分组" aria-label="Permalink to &quot;忽略分组&quot;">​</a></h2><p>不希望捕获某些分组，只需要在分组内加上<code>?:</code>就可以</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Byraon).(ok)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><h2 id="前瞻和后顾" tabindex="-1">前瞻和后顾 <a class="header-anchor" href="#前瞻和后顾" aria-label="Permalink to &quot;前瞻和后顾&quot;">​</a></h2><table><thead><tr><th>名称</th><th>正则</th><th>含义</th></tr></thead><tbody><tr><td>正向前瞻</td><td>exp(?=assert)</td><td>所谓前瞻，即向前看，就是看字符串位置的右边</td></tr><tr><td>负向前瞻</td><td>exp(?!assert)</td><td></td></tr><tr><td>正向后顾</td><td>exp(?&lt;=assert)</td><td>所谓后顾，即向后看，就是看字符串位置的左边</td></tr><tr><td>负向后顾</td><td>exp(?&lt;!assert)</td><td></td></tr></tbody></table>',15),i=[s];function h(l,n,p,o,c,k){return a(),d("div",null,i)}const g=t(r,[["render",h]]);export{x as __pageData,g as default};
