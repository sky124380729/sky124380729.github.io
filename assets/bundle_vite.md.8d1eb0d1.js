import{_ as e,o as t,c as a,O as i}from"./chunks/framework.ff3dc444.js";const v=JSON.parse('{"title":"Vite","description":"","frontmatter":{},"headers":[],"relativePath":"bundle/vite.md","filePath":"bundle/vite.md","lastUpdated":1687751075000}'),o={name:"bundle/vite.md"},l=i('<h1 id="vite" tabindex="-1">Vite <a class="header-anchor" href="#vite" aria-label="Permalink to &quot;Vite&quot;">​</a></h1><h2 id="vite本身服务器也不错" tabindex="-1">Vite本身服务器也不错 <a class="header-anchor" href="#vite本身服务器也不错" aria-label="Permalink to &quot;Vite本身服务器也不错&quot;">​</a></h2><ul><li>vite不打包，打包写的什么就是什么，甚至vue文件都不编译，通过请求头设置为<code>application/javascript</code>直接抓取vue文件</li><li>生产环境可以开启https,直接dev启动给用户使用，前提是用户的浏览器要支持es module</li><li>缺点就是代码都暴露了</li></ul><h2 id="vite依赖是强缓存-开发源码是协商缓存-所以调试node-modules的时候会有问题" tabindex="-1">Vite依赖是强缓存，开发源码是协商缓存，所以调试node_modules的时候会有问题 <a class="header-anchor" href="#vite依赖是强缓存-开发源码是协商缓存-所以调试node-modules的时候会有问题" aria-label="Permalink to &quot;Vite依赖是强缓存，开发源码是协商缓存，所以调试node\\_modules的时候会有问题&quot;">​</a></h2><blockquote><p>解析后的依赖请求会以 HTTP 头 max-age=31536000,immutable 强缓存，以提高在开发时的页面重载性能。一旦被缓存，这些请求将永远不会再到达开发服务器。如果安装了不同的版本（这反映在包管理器的 lockfile 中），则附加的版本 query 会自动使它们失效。如果你想通过本地编辑来调试依赖项，你可以:</p></blockquote><ul><li>通过浏览器 devtools 的 Network 选项卡暂时禁用缓存；</li><li>重启 Vite dev server，使用 --force 标志重新打包依赖；</li><li>重新载入页面。</li></ul>',6),d=[l];function r(s,n,c,u,_,h){return t(),a("div",null,d)}const p=e(o,[["render",r]]);export{v as __pageData,p as default};
