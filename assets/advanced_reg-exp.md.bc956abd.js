import{_ as t,o as d,c as e,a as r}from"./app.b5b89a77.js";const u=JSON.parse('{"title":"RegExp","description":"","frontmatter":{},"headers":[{"level":2,"title":"可视化：regexper","slug":"可视化-regexper","link":"#可视化-regexper","children":[]},{"level":2,"title":"快速测试","slug":"快速测试","link":"#快速测试","children":[]},{"level":2,"title":"速查表","slug":"速查表","link":"#速查表","children":[]},{"level":2,"title":"非贪婪模式","slug":"非贪婪模式","link":"#非贪婪模式","children":[]},{"level":2,"title":"忽略分组","slug":"忽略分组","link":"#忽略分组","children":[]},{"level":2,"title":"前瞻和后顾","slug":"前瞻和后顾","link":"#前瞻和后顾","children":[]}],"relativePath":"advanced/reg-exp.md","lastUpdated":1678721436000}'),a={name:"advanced/reg-exp.md"},s=r(`<h1 id="regexp" tabindex="-1">RegExp <a class="header-anchor" href="#regexp" aria-hidden="true">#</a></h1><nav class="table-of-contents"><ul><li><a href="#可视化-regexper">可视化：regexper</a></li><li><a href="#快速测试">快速测试</a></li><li><a href="#速查表">速查表</a></li><li><a href="#非贪婪模式">非贪婪模式</a></li><li><a href="#忽略分组">忽略分组</a></li><li><a href="#前瞻和后顾">前瞻和后顾</a></li></ul></nav><h2 id="可视化-regexper" tabindex="-1">可视化：<a href="https://regexper.com" target="_blank" rel="noreferrer">regexper</a> <a class="header-anchor" href="#可视化-regexper" aria-hidden="true">#</a></h2><h2 id="快速测试" tabindex="-1">快速测试 <a class="header-anchor" href="#快速测试" aria-hidden="true">#</a></h2><p>待开放...</p><h2 id="速查表" tabindex="-1">速查表 <a class="header-anchor" href="#速查表" aria-hidden="true">#</a></h2><table><thead><tr><th>规则</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>\\</td><td>转义</td><td></td></tr><tr><td>^</td><td>匹配输入的开始</td><td></td></tr><tr><td>$</td><td>匹配输入的结束</td><td></td></tr><tr><td>*</td><td>匹配前一个表达式0次或多次</td><td></td></tr><tr><td>+</td><td>匹配前一个表达式1次或多次</td><td>等价于 <code>{1,}</code></td></tr><tr><td>?</td><td>匹配前一个表达式0次货1次</td><td>等价于 <code>{0,1}</code></td></tr><tr><td>.</td><td>默认匹配除了换行符之外的任何单个字符</td><td></td></tr><tr><td>x(?=y)</td><td>匹配&#39;x&#39;仅仅当&#39;x&#39;后面跟着&#39;y&#39;</td><td>先行断言</td></tr><tr><td>(?&lt;=y)x</td><td>匹配&#39;x&#39;仅当&#39;x&#39;前面是&#39;y&#39;</td><td>后行断言</td></tr><tr><td>x(?!y)</td><td>仅仅当&#39;x&#39;后面不跟着&#39;y&#39;时匹配&#39;x&#39;</td><td>正向否定查找</td></tr><tr><td>(?&lt;!y)x</td><td>仅仅当&#39;x&#39;前面不是&#39;y&#39;时匹配&#39;x&#39;</td><td>反向否定查找</td></tr><tr><td>x|y</td><td>匹配&#39;x&#39;或者&#39;y&#39;</td><td></td></tr><tr><td>{n}</td><td>匹配了前面一个字符刚好出现了 n 次</td><td>n 是正整数</td></tr><tr><td>{n,}</td><td>匹配前一个字符至少出现了n次</td><td>n 是正整数</td></tr><tr><td>{n,m}</td><td>匹配前面的字符至少n次，最多m次</td><td>m,n 是正整数</td></tr><tr><td>[xyz]</td><td>一个字符集合。匹配方括号中的任意字符</td><td></td></tr><tr><td>[^xyz]</td><td>匹配任何没有包含在方括号中的字符</td><td></td></tr><tr><td>\\b</td><td>匹配一个词的边界，例如在字母和空格之间</td><td></td></tr><tr><td>\\B</td><td>匹配一个非单词边界</td><td></td></tr><tr><td>\\d</td><td>匹配一个数字</td><td></td></tr><tr><td>\\D</td><td>匹配一个非数字字符</td><td></td></tr><tr><td>\\f</td><td>匹配一个换页符</td><td></td></tr><tr><td>\\n</td><td>匹配一个换行符</td><td></td></tr><tr><td>\\r</td><td>匹配一个回车符</td><td></td></tr><tr><td>\\s</td><td>匹配一个空白字符，包括空格、制表符、换页符和换行符</td><td></td></tr><tr><td>\\S</td><td>匹配一个非空白字符</td><td></td></tr><tr><td>\\w</td><td>匹配一个单字字符（字母、数字或者下划线）</td><td></td></tr><tr><td>\\W</td><td>匹配一个非单字字符</td><td></td></tr></tbody></table><h2 id="非贪婪模式" tabindex="-1">非贪婪模式 <a class="header-anchor" href="#非贪婪模式" aria-hidden="true">#</a></h2><blockquote><p>让正则表达式尽可能少的匹配，也就是说一旦成功匹配不再继续尝试就是非贪婪模式，做法很简单，在两次后加上<code>?</code>即可</p></blockquote><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">123456789</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">match</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">/</span><span style="color:#C3E88D;">\\d</span><span style="color:#89DDFF;">{3,5}?/</span><span style="color:#F78C6C;">g</span><span style="color:#A6ACCD;">) </span><span style="color:#676E95;font-style:italic;">// [&quot;123&quot;, &quot;456&quot;, &quot;789&quot;]</span></span>
<span class="line"></span></code></pre></div><h2 id="忽略分组" tabindex="-1">忽略分组 <a class="header-anchor" href="#忽略分组" aria-hidden="true">#</a></h2><p>不希望捕获某些分组，只需要在分组内加上<code>?:</code>就可以</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">?:</span><span style="color:#A6ACCD;">Byraon)</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">(ok)</span></span>
<span class="line"></span></code></pre></div><h2 id="前瞻和后顾" tabindex="-1">前瞻和后顾 <a class="header-anchor" href="#前瞻和后顾" aria-hidden="true">#</a></h2><table><thead><tr><th>名称</th><th>正则</th><th>含义</th></tr></thead><tbody><tr><td>正向前瞻</td><td>exp(?=assert)</td><td>所谓前瞻，即向前看，就是看字符串位置的右边</td></tr><tr><td>负向前瞻</td><td>exp(?!assert)</td><td></td></tr><tr><td>正向后顾</td><td>exp(?&lt;=assert)</td><td>所谓后顾，即向后看，就是看字符串位置的左边</td></tr><tr><td>负向后顾</td><td>exp(?&lt;!assert)</td><td></td></tr></tbody></table>`,15),l=[s];function n(o,p,i,c,h,x){return d(),e("div",null,l)}const g=t(a,[["render",n]]);export{u as __pageData,g as default};
