import{_ as e,c as l,o,V as i}from"./chunks/framework.OaYh-_yc.js";const _=JSON.parse('{"title":"Framework","description":"","frontmatter":{},"headers":[],"relativePath":"advanced/framework.md","filePath":"advanced/framework.md","lastUpdated":1706930496000}'),d={name:"advanced/framework.md"},a=i('<h1 id="framework" tabindex="-1">Framework <a class="header-anchor" href="#framework" aria-label="Permalink to &quot;Framework&quot;">​</a></h1><blockquote><p>关于框架设计的一些思考</p></blockquote><nav class="table-of-contents"><ul><li><a href="#软件设计原则">软件设计原则</a></li><li><a href="#软件设计分层">软件设计分层</a></li><li><a href="#编程范式">编程范式</a><ul><li><a href="#性能">性能</a></li><li><a href="#可维护性">可维护性</a></li><li><a href="#总结">总结</a></li></ul></li><li><a href="#框架设计">框架设计</a></li></ul></nav><h2 id="软件设计原则" tabindex="-1">软件设计原则 <a class="header-anchor" href="#软件设计原则" aria-label="Permalink to &quot;软件设计原则&quot;">​</a></h2><ul><li><p>单一职责原则</p><ul><li>概念：永远不应该有多语义一个原因来改变某个类</li><li>理解：对于一个类而言，应该仅有一个引起它变化的原因</li><li>应用：如果一个类拥有了两种职责，那就可以将这个类分成两个类</li></ul></li><li><p>开放封闭原则</p><ul><li>概念：软件实体扩展应该是开放的，但对于修改应该是封闭的</li><li>理解：<code>对扩展开放，对修改封闭</code>。可以去扩展类，尽量不要去修改类</li><li>应用：当需求有改动，尽量用继承或者组合的方式来扩展类的功能，而不是直接去修改类的代码</li></ul></li><li><p>里氏替换原则（deprecated）</p><ul><li>理解：父类一定能被子类替换</li></ul></li><li><p>迪米特原则（最少知识原则）</p><ul><li>概念：只与你最直接的对象交流</li><li>理解：<code>高内聚，低耦合</code></li><li>应用：做系统设计时，尽量减小依赖关系</li></ul></li><li><p>接口隔离原则</p><ul><li>一个类与另一个类直接的依赖性，应该依赖于尽可能小的接口</li><li>理解：不要对外暴露没有实际意义的接口。用户不应该依赖它不需要的接口</li><li>应用：当需要对外暴露接口时，如果是非必要对外提供，尽量删除</li></ul></li><li><p>依赖倒置原则</p><ul><li>高层模块不应该依赖于底层模块，他们应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象</li><li>理解：应该面向接口编程，不应该面向实现类编程</li></ul></li></ul><p>以上原则英文首字母拼在一起就是<code>SOLID</code>(稳定的)，所以也称之为<code>SOLID</code>原则</p><p>以下是一些补充的设计原则</p><ul><li><p>组合/聚合复用原则</p><ul><li>当要扩展类的功能时，优先考虑使用<code>组合</code>，而不是<code>继承</code></li><li>该原则在23中经典设计模式中频繁使用</li><li>如：代理模式、装饰模式、适配器模式</li></ul></li><li><p>无环依赖选择</p><ul><li>当A依赖B,B依赖C，C依赖A，此时会出现循环依赖</li><li>在设计中避免该问题，可通过引入<code>中介者模式</code>解决</li></ul></li><li><p>共同封装原则</p><ul><li>应该将易变的类放在同一个包里，将变化隔离出来</li><li>该原则是基于<code>开放封闭</code>的延伸</li></ul></li></ul><h2 id="软件设计分层" tabindex="-1">软件设计分层 <a class="header-anchor" href="#软件设计分层" aria-label="Permalink to &quot;软件设计分层&quot;">​</a></h2><ul><li>系统级架构 <ul><li>应用在整个系统内，如与后台服务如何通信，与第三方系统如何集成</li><li>设计前端首要条件：了解前端系统与其他系统之间的关系，包括<code>业务关系</code>和<code>协作机制</code></li><li>设计后端：只需要规定与后端数据传递的机制，包括<code>api</code>设计规则，访问授权的一个开放标准(oAuth)跳转token的验证，数据传递<code>Cookie</code>等</li><li>前端与后端的关系主要考虑的因素：前后端分离架构的设计，前后端分离架构其实是如何实施<code>技术决策</code>，<code>用户鉴权</code>，<code>API结构管理和设计</code>，<code>API文档管理</code>，<code>Mock的使用</code>，<code>BFF</code>(服务于前端的后端，nodejs)，<code>是否需要服务端渲染</code>等</li></ul></li><li>应用级架构 <ul><li>应用级架构可以看做是系统级架构的细化</li><li>单个应用与其他外部应用的关系，微服务/微前端框架下多个应用的协作，数据交换等</li><li>一般包含<code>脚手架</code>，<code>模式库</code>，<code>设计系统</code></li></ul></li><li>模块级架构 <ul><li>业务编码执行进行设计，我们称之为迭代</li></ul></li><li>代码级架构 <ul><li>规范与原则，一般指的是<code>开发流程</code>，<code>代码质量以及改善</code>，<code>规范而非默契</code></li></ul></li></ul><h2 id="编程范式" tabindex="-1">编程范式 <a class="header-anchor" href="#编程范式" aria-label="Permalink to &quot;编程范式&quot;">​</a></h2><ul><li>命令式编程：<code>详细描述做事过程</code>的方式就叫<code>命令式</code>，命令式变成的核心是<code>关注过程</code></li><li>声明式编程：我们在使用Vue<code>模板语法</code>的时候，实际上就是使用的<code>声明式</code>编程，因此所谓的声明式，就是<code>只关注结果，不关注过程</code>（不代表不需要过程，声明式只是把过程隐藏了）</li></ul><h3 id="性能" tabindex="-1">性能 <a class="header-anchor" href="#性能" aria-label="Permalink to &quot;性能&quot;">​</a></h3><p>命令式的性能 <code>优于</code> 声明式的性能</p><h3 id="可维护性" tabindex="-1">可维护性 <a class="header-anchor" href="#可维护性" aria-label="Permalink to &quot;可维护性&quot;">​</a></h3><p>声明式的可维护性 <code>优于</code> 命令式的可维护性</p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>企业级的项目中，考虑成本和开发体验（心智负担），声明式的项目要<code>明显优于</code>命令式的项目，也因此，现在选择新项目基本上都是选择<code>Vue</code>而非<code>jQuery</code></p><h2 id="框架设计" tabindex="-1">框架设计 <a class="header-anchor" href="#框架设计" aria-label="Permalink to &quot;框架设计&quot;">​</a></h2><p>尤雨溪在一次演讲中提到：框架的设计过程其实是一个<code>不断取舍</code>的过程</p><p>对于<code>Vue</code>框架而言，调用者是使用<code>声明式</code>的方式去使用框架，而<code>Vue</code>内部是通过<code>命令式</code>的方式进行实现</p><p>可以理解为，<code>Vue</code>封装了<code>命令式</code>的逻辑，而对外暴露了<code>声明式</code>的接口</p><p>框架作者需要做的就是封装命令式逻辑，同时<code>尽可能减少性能的损耗</code>，它需要在<code>性能</code>和<code>可维护性</code>之间，找到一个平衡点，从而找到<code>可维护性更好，性能相对更优</code>的点</p>',23),c=[a];function r(t,u,h,p,n,s){return o(),l("div",null,c)}const m=e(d,[["render",r]]);export{_ as __pageData,m as default};
